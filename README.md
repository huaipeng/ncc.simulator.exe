# **ncc.simulator**
The neuromorphic chip simulator, coded in C++, OpenMP, CUDA, is named 'ncc.simulator' and is compatible with Ubuntu 18.04.4 LTS. Further details about the simulator can be found in the associated paper.: H. Zhang et al., "Simeuro: A Hybrid CPU-GPU Parallel Simulator for Neuromorphic Computing Chips," in IEEE Transactions on Parallel and Distributed Systems, vol. 34, no. 10, pp. 2767-2782, Oct. 2023, doi: 10.1109/TPDS.2023.3291795.keywords: {Neurons;Hardware;Computational modeling;Task analysis;Biological neural networks;Routing;Behavioral sciences;Neuromorphic computing;chip simulation;deep learning}, The paper was published at IEEE Transactions on Parallel and Distributed Systems https://ieeexplore.ieee.org/document/10172030

## 1. **Installing the Protobuf Library Before Running the Simulator**

The simulator requires a dependency library: Protobuf. The version of Protobuf utilized by the simulator is 3.4.0. You can acquire the source code from the following link:

      https://github.com/google/protobuf/releases/download/v3.4.0/protobuf-cpp-3.4.0.zip

Once the source code is downloaded, users can proceed to install the Protobuf library from the source code by following the steps outlined below:

  1.1   ***Install dependency libraries of the protobuf***. To ensure proper installation of Protobuf from source code, it is necessary to install the required dependency libraries. On Ubuntu, you can execute the following command to install the dependencies for Protobuf:

     $ sudo apt-get install autoconf automake libtool curl make g++ unzip

1.2  ***Install the protobuf***. Unzip the package and then navigate into the extracted folder named protobuf-3.4.0. Initially, generate the configuration script:

     $ ./autogen.sh

Next, proceed to build and install both the Protocol Buffer runtime and the Protocol Buffer compiler (protoc) by executing the following commands:

     $ ./configure
     $ make
     $ make check
     $ sudo make install
     $ sudo ldconfig # refresh shared library cache.


If "make check" fails, you can still install, but it is likely that some features of this library will not work correctly on your system.

## 2. **Install Boost Library**

To install the Boost library directly, use the following command. The simulator utilizes Boost library version 1.65.1.

    $ sudo apt-get install libboost-all-dev

After installation, you can check your boost library in your machine using following command :

    $ dpkg -s libboost-dev | grep 'Version'

  
  ## 2. **Software Architecture of the Simulator**

The diagram below illustrates the architecture of the simulator, providing a general overview of its functionalities. The upper section comprises a list of cores responsible for core processing, while the lower section consists of two different communication networks: an ideal network and a 2D-mesh network. In the ideal network, spikes are directly transferred from the injection buffer to the ejection buffer, whereas in the 2D-mesh network, spikes are routed through the router matrix. The central component is the network interface, housing two crucial memory buffers: the injection buffer, which stores all spikes generated by the neurons, and the ejection buffer, which stores spikes serving as inputs for all axons on the chip.

<img width="561" alt="image" src="https://user-images.githubusercontent.com/42291598/102766951-da92da00-43b9-11eb-8028-052296a4a461.png">

## 3. **Simulator’s Features:**

  3.1 ***Two types of crossbars: digital and RRAM.*** In the digital crossbar, a single value stores trained weights, whereas the RRAM crossbar employs pairs of resistances to hold trained weights.

3.2 ***Two types of communication networks: ideal and router-based 2D-mesh.*** Users can opt for the ideal network for accelerated speed or the 2D-mesh network to analyze communication traffic flow.

3.3 ***Read-noise and write-noise simulation on RRAM crossbar.*** The simulator can simulate read-noise at each tick, while write-noise occurs only during value fusion onto the RRAM crossbar.

3.4 ***Defect simulation on RRAM crossbar.*** The simulator can simulate defects on the RRAM crossbar. Users can specify the percentage of defects to explore the relationship between chip performance and defect percentage.

3.5 ***Power estimation in core and router processing.*** The simulator can model each operation within a real chip and record the accumulated energy for these operations.

3.6 ***Parallel computation for accelerated speed.*** The simulator can leverage multi-core processors on high-performance machines to reduce simulation time. Additionally, it is compatible with GPUs using CUDA programming.

3.7 ***Two computing modes: ANN and SNN.*** SNN (spike neural network) and ANN (artificial neural network) modes utilize original values as chip inputs.

## 4. **Requirements for the Simulator:**

4.1  ***Simulation configuration file.*** This file contains all global settings for the simulator.

4.2  ***Chip configuration file.*** This file defines the layout of the chip, including the number of cores and their sizes.

4.3  ***Bitstream configuration file.*** This file includes weight matrices for each core and connections between cores, along with neuron settings.

4.4  ***Input folder containing spike source files.*** This folder specifies the input data for the simulation, including all spike sources in CSV format.

4.5  ***Execution file: ncc.simulator.*** This binary execution file is compiled for Ubuntu 18.04.4 LTS.

## 5. **Input File Format for the Simulator in SNN Mode:**

The input file is in CSV format, containing spike trains for each axon. It consists of three columns: time step, core ID, and axon ID. In the image below, the left side displays an example segment from a spike source file, while the right side shows sorted records by the last column 'axon ID' from the same spike source file. This demonstrates all spikes at different steps for a particular axon.

<img width="659" src="https://user-images.githubusercontent.com/42291598/102757109-c34cf000-43ab-11eb-972f-753b4dba99dd.png">

## 6. **Output File Format from the Simulator in SNN Mode:**

When users specify the output cores in the simulation configuration file, the simulator generates spike output for each spike source and stores it in a corresponding file with the extension '.sink'. The '.sink' file is also in CSV format and includes five columns: time step, source core ID, source neuron ID, destination core ID, destination axon ID. The image below displays an example segment from one '.sink' file.

<img width="539" alt="Screenshot 2022-12-21 at 5 05 42 PM" src="https://user-images.githubusercontent.com/42291598/102759234-cd242280-43ae-11eb-968a-7cbad683263f.png">

From the 'sink' file, users can compute the following information:

- Calculate statistics about spike output from a particular core using the 'src core id' column.

- Determine the average spike ratio per tick between different cores using the 'src core id' and 'dest core id' columns.

- Make predictions for the final class using either the 'src neuron id' or 'dest axon id' columns.

## 7. **Input File Format for the Simulator in ANN Mode:**

The ANN mode enables users to pinpoint issues in mapping by using real values as inputs for chip simulation. Users can compare these values between the simulator output and TensorFlow outputs. The image below displays an example segment from an input file for ANN mode simulation. It contains four columns: time step, source core id, source axon id, and spiked value (a floating-point value equivalent to one pixel value in the input image).

<img width="364" alt="Screenshot 2022-12-21 at 5 23 18 PM" src="https://user-images.githubusercontent.com/42291598/102760975-4290f280-43b1-11eb-83d5-da1e55fb6b2b.png">

The input file contains only one time-step because, in the ANN mode, the inputs are fed into the chip at a single time. The last column in the input file includes the original floating-point values.

## 8. **Output File Format from the Simulator in ANN Mode:**

The output files consist of six columns when the ANN mode is specified: time step, source core id, source axon id, destination core id, destination axon id, and spiked value. The image below displays an example segment from one 'sink' file.

<img width="539" alt="Screenshot 2022-12-21 at 5 05 42 PM" src="https://user-images.githubusercontent.com/42291598/102762249-fe9eed00-43b2-11eb-826c-3aa5a691e33f.png">

From the provided 'sink' file in the ANN mode, users can carry out the following computations:

- Compare the simulator’s output and TensorFlow output using the columns 'spiked value', 'src core id', and 'src neuron id'.
- Make predictions for the final class using the columns 'src neuron id' or 'dest axon id' and 'spiked value'.

## 9. **Case Study: 21-Core Simulation for MNIST Classification:**

The image below illustrates the entire pipeline when a user wants to simulate a neuromorphic chip's operation. The process involves three steps:

- Building the neural network model,
- Mapping the model onto the chip,
- Performing the simulation using the simulator.

<img width="792" alt="Screenshot 2022-12-21 at 5 40 59 PM" src="https://user-images.githubusercontent.com/42291598/102763241-5d189b00-43b4-11eb-9049-af4944ea54d0.png">

## 10. Running the Simulator and Exploring its Features

To get started, clone the example folder from the repository:

```bash
$ git clone https://github.com/huaipeng/ncc.simulator.exe.git
```

All necessary configuration files and input files are available in the '25-cores' folder. After cloning the example folder and navigating into the '25-cores' directory, you can execute the following command to run the simulator:

```bash
./ncc.simulator simulation_config_digital.json
```

The executable file is *'ncc.simulator'*, and the configuration file *'simulation_config_digital.json'* contains various settings for the simulator. Once the simulator is run, you'll find the output files with extensions like '*.sink' in the same folder as the spike sources.

The first image below illustrates the process of running the simulator: typing the simulator name with a simulation configuration file as the input argument. The simulator loads spike sources one by one from the input folder, produces corresponding 'sink' files, and prints out the 'sink' filenames on the console.

![Simulator Running](https://user-images.githubusercontent.com/42291598/120434561-3624b300-c3af-11eb-8470-8285b1024a9f.png)

The second image showcases the processing of output files to predict the final class for each output and compute the final accuracy for the entire dataset.

![Output Processing](https://user-images.githubusercontent.com/42291598/120434570-391fa380-c3af-11eb-833c-fa98c5656b26.png)

