# **ncc.simulator**
Neuromorphic chip simulator is developed by C++, the simulator instance named as 'ncc.simulator' can run on the Ubuntu 18.04.4 LTS, with OpenMP version, CUDA. more details about the simulator was shown in the paper: H. Zhang et al., "Simeuro: A Hybrid CPU-GPU Parallel Simulator for Neuromorphic Computing Chips," in IEEE Transactions on Parallel and Distributed Systems, vol. 34, no. 10, pp. 2767-2782, Oct. 2023, doi: 10.1109/TPDS.2023.3291795.
keywords: {Neurons;Hardware;Computational modeling;Task analysis;Biological neural networks;Routing;Behavioral sciences;Neuromorphic computing;chip simulation;deep learning},

 

## 1. **Install Protobuf Library Before to Run the Simulator**

The simulator requires a dependency library: Protobuf. The version of Protobuf utilized by the simulator is 3.4.0. You can acquire the source code from the following link:

      https://github.com/google/protobuf/releases/download/v3.4.0/protobuf-cpp-3.4.0.zip

Once the source code is downloaded, users can proceed to install the Protobuf library from the source code by following the steps outlined below:

  1.1   ***Install dependency libraries of the protobuf***. To ensure proper installation of Protobuf from source code, it is necessary to install the required dependency libraries. On Ubuntu, you can execute the following command to install the dependencies for Protobuf:

     $ sudo apt-get install autoconf automake libtool curl make g++ unzip

1.2  ***Install the protobuf***. Unzip the package and then navigate into the extracted folder named protobuf-3.4.0. Initially, generate the configuration script:

     $ ./autogen.sh

Next, proceed to build and install both the Protocol Buffer runtime and the Protocol Buffer compiler (protoc) by executing the following commands:

     $ ./configure
     $ make
     $ make check
     $ sudo make install
     $ sudo ldconfig # refresh shared library cache.


If "make check" fails, you can still install, but it is likely that some features of this library will not work correctly on your system.

## 2. **Install Boost Library**

To install the Boost library directly, use the following command. The simulator utilizes Boost library version 1.65.1.

    $ sudo apt-get install libboost-all-dev

After installation, you can check your boost library in your machine using following command :

    $ dpkg -s libboost-dev | grep 'Version'

  
  ## 2. **the Software Architecture of the Simulator**

The diagram below illustrates the architecture of the simulator, providing a general overview of its functionalities. The upper section comprises a list of cores responsible for core processing, while the lower section consists of two different communication networks: an ideal network and a 2D-mesh network. In the ideal network, spikes are directly transferred from the injection buffer to the ejection buffer, whereas in the 2D-mesh network, spikes are routed through the router matrix. The central component is the network interface, housing two crucial memory buffers: the injection buffer, which stores all spikes generated by the neurons, and the ejection buffer, which stores spikes serving as inputs for all axons on the chip.

<img width="561" alt="image" src="https://user-images.githubusercontent.com/42291598/102766951-da92da00-43b9-11eb-8028-052296a4a461.png">

## 3. **Simulator’s features:**

  3.1 ***Two types of crossbars: digital and RRAM.*** In the digital crossbar, a single value stores trained weights, whereas the RRAM crossbar employs pairs of resistances to hold trained weights.

3.2 ***Two types of communication networks: ideal and router-based 2D-mesh.*** Users can opt for the ideal network for accelerated speed or the 2D-mesh network to analyze communication traffic flow.

3.3 ***Read-noise and write-noise simulation on RRAM crossbar.*** The simulator can simulate read-noise at each tick, while write-noise occurs only during value fusion onto the RRAM crossbar.

3.4 ***Defect simulation on RRAM crossbar.*** The simulator can simulate defects on the RRAM crossbar. Users can specify the percentage of defects to explore the relationship between chip performance and defect percentage.

3.5 ***Power estimation in core and router processing.*** The simulator can model each operation within a real chip and record the accumulated energy for these operations.

3.6 ***Parallel computation for accelerated speed.*** The simulator can leverage multi-core processors on high-performance machines to reduce simulation time. Additionally, it is compatible with GPUs using CUDA programming.

3.7 ***Two computing modes: ANN and SNN.*** SNN (spike neural network) and ANN (artificial neural network) modes utilize original values as chip inputs.

## 4. **What is Needed for the Simulator:**
   4.1  ***The simulation configuration file.*** This file include all global settings for the simulator.
   
   4.2  ***The chip configuration file.*** This file define the chip layout including core number and core size.
   
   4.3  ***The bitstream configuration file.*** This file include weight matrics for each core and connections between cores and neuron settings.
   
   4.4  ***The input folder including spike source files.*** This folder specify the input folder for the simulation including all spike sources in CSV format
   
   4.5  ***The execution file : ncc.simulator.*** This is binary execution file which is compiled on Ubuntu 18.04.4 LTS.

## 5. **The input file format for the simulator in the SNN mode:**

The input file is in the CSV format holding spike trains for each axon. three columns are included: time step, core id, axon id. In the below picture, the left side display one example segment from one spike source file; the right side display the sorted records by last column 'axon id' from the same spike source file, which demonstrate all the spikes at different steps for one particular axon.

<img width="659" src="https://user-images.githubusercontent.com/42291598/102757109-c34cf000-43ab-11eb-972f-753b4dba99dd.png">

## 6. **The Output file format from the simulator in the SNN mode:**

When user specify the output cores in the simulation configuration file, the simulator will produce spike output for each spike source and store into one corresponding file with the extension name '.sink'. The '.sink' file is also in CSV format and include five columns : time step, source code id, source neuron id, destination code id, destination axon id.  The following picture display one example segment from one '.sink' file

<img width="539" alt="Screenshot 2022-12-21 at 5 05 42 PM" src="https://user-images.githubusercontent.com/42291598/102759234-cd242280-43ae-11eb-968a-7cbad683263f.png">

The user can compute following information from the 'sink' file:

- Compute the statistics about spike output from one particular core using column ’src core id’.

- Compute average spike ratio per tick between different cores using the column ‘src core id’ and ‘dest core id’

- Compute predication for final class  using the column ‘src neuron id’ or ‘dest axon id’


## 7. **The input file format for the simulator in the ANN mode:**

The ANN mode can help user to locate the issues in the mapping because the real values are the inputs of the chip simulation. The user can compare the values between the simulator output and Tensorflow outputs. The following picture display one example segment from one input file for ANN mode simulation. The four columns are included: time step, source core id, source axon id, spiked value (floating-point value which is equal to one pixel value in the input image).

<img width="364" alt="Screenshot 2022-12-21 at 5 23 18 PM" src="https://user-images.githubusercontent.com/42291598/102760975-4290f280-43b1-11eb-83d5-da1e55fb6b2b.png">

The input file only include one time-step because in the ANN mode, the inputs are fed into the chip at one time. the last column in the input file include original floating-point values.

## 8. **The output file format from the simulator in the ANN mode:**

The output files include six columns when user specify the ANN mode : time step, source code id, source axon id, destination core id, destination axon id, spiked value. The following picture display one example segment from one 'sink' file:

<img width="539" alt="Screenshot 2022-12-21 at 5 05 42 PM" src="https://user-images.githubusercontent.com/42291598/102762249-fe9eed00-43b2-11eb-826c-3aa5a691e33f.png">

From the above 'sink' file in the ANN mode, user can perform the following computing:

- Compare simulator’s output and Tensorflow output using the column ‘spiked value’ and ‘src core id’ and ‘src neuron id’
- Compute predication for final class using the column ‘src neuron id’ or ‘dest axon id’ and ’spiked value’

## 9. **One case study for 21-core simulation for MNIST classification:**

The following picture demonstrate the entire pipeline when user want to simulate neuromorphic chip how to work. The three steps are needed: 

- Build the neural network model,
- Map the model onto the chip, 
- Perform the simulation on the simulator.

<img width="792" alt="Screenshot 2022-12-21 at 5 40 59 PM" src="https://user-images.githubusercontent.com/42291598/102763241-5d189b00-43b4-11eb-9049-af4944ea54d0.png">

## 10. Run the Simulator and Explore its Features

Clone the example folder from repository:

       $ git clone https://github.com/huaipeng/ncc.simulator.exe.git
       
All the necessary configuration files and input files are ready in the folder '25-cores', after user clone the example folder and navigate into the folder '25-cores', he can type the following command to run the simualtor:
~~~~
./ncc.simulator simulation_config_digital.json
~~~~

The executable file is *'ncc.simulator'* and the configuration file *'simulation_config_digital.json'* including different settings for the simulator. After you run the simulator, you can find the output file with the extension named like '*.sink' in the same folder as the spike sources.

The following picture display the progress to run the simulator: type the simulator name with one simulation configuration file as input argument. The simulator will load spike source one by one from input folder and produce corresponding 'sink' file and print out the 'sink' filename on the console.

<img width="935" alt="Screenshot 2023-06-02 at 1 56 43 PM" src="https://user-images.githubusercontent.com/42291598/120434561-3624b300-c3af-11eb-8470-8285b1024a9f.png">

The following picture display the processing of output files in order to predict final class for each output and also compute final accuracy for entire dataset.

<img width="732" alt="Screenshot 2023-06-02 at 2 30 35 PM" src="https://user-images.githubusercontent.com/42291598/120434570-391fa380-c3af-11eb-833c-fa98c5656b26.png">

